{"pages":[{"title":"","text":"xvym.github.ioXv’s blog.","link":"/README.html"}],"posts":[{"title":"Hello World!","text":"2020-08-02搞了一下午终于把blog搞好了。挺好玩的，还有很多设置可以搞一搞。下面是Hexo官方自带的说明和一些基本操作。头像是我的爱猫大狗。 NotesWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/08/02/2020-08-02-hello-world/"},{"title":"【阅读笔记】深入理解JVM虚拟机：第二章","text":"Java内存区域与内存溢出异常 1.数据区域 1.1.运行时数据区域 线程共享 方法区(Method Area) 存储已被虚拟机加载的类型信息、常量、静态变量、JIT编译后的代码缓存等数据 常量池表位于该区域 无法满足新的内存分配需求时，抛出OOM异常 堆(Heap) 在虚拟机启动时创建，存放几乎所有的对象实例，垃圾收集器GC就作用于此 通过-Xmx和-Xms设定容量扩展 当内存容量不足以完成对象实例化时，会抛出OOM异常 线程私有（生命周期与当前线程相同） 虚拟机栈(VM Stack) 每个方法被执行时，虚拟机会同步创建一个栈帧（StackFrame），存储一个方法执行时的变量表、操作数栈、动态链接、方法出口等信息 每个方法被调用到执行完毕，就是一个栈帧从入栈到出栈的过程 若方法调用过深，导致栈帧累计内存超过-Xss，会抛出SOF异常 如果设置了栈内存动态扩展，当栈扩展超出内存容量时会抛出OOM异常 本地方法栈（Native Method Stack） 与虚拟机机栈的作用类似，区别是虚拟机栈为虚拟机执行Java方法服务，本地方法栈为虚拟机使用到的本地方法（Native）服务 异常抛出情况与虚拟机栈一致 程序计数器（Program Counter Register） 当前线程所执行的字节码的行号指示器 唯一一个不会OOM的区域 1.2.直接内存 非虚拟机运行数据区 JDK的NIO类可以使用Native函数库直接分配堆外内存，也会出现OOM 2.虚拟机对象探秘 对象的创建 虚拟机遇到字节码new指令时的处理过程——第七章详解 对象的布局 对象头(Header) 实例数据(InstanceData) 3.OOM异常 分析OOM 确认是内存泄漏(Memory Leak) 还是内存溢出(Menory OverFlow) ，分析内存映像。 扩展虚拟机内存设置 检查代码问题 虚拟机栈和本地方法栈溢出 制造溢出场景的方法：减少栈内存容量并通制造大量本地变量，增大次方法帧中的变量表长度2.使用默认参数时，HotSpot虚拟机的栈深度一般可以达到1000~2000 方法区和运行时常量池溢出","link":"/2020/08/02/2020-08-02-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"title":"我的书单","text":"阅读计划《spring-framework-reference》《Redis设计与实现》《Java并发编程的艺术》《Linux内核设计的艺术》《深入理解Kafka》《Go语言——从入门到进阶实战》《操作系统》 2020年阅读记录二月《Spring实战》 三月《SpringBoot揭秘：快速构建微服务体系》《SpringBoot开发实战》 四月None 五月《Python编程：从入门到实践》 六月《网络是怎样连接的》 七月《操作系统》——30% 八月《深入理解JVM虚拟机》","link":"/2020/08/02/2020-08-02-%E6%88%91%E7%9A%84%E4%B9%A6%E5%8D%95/"},{"title":"字节码文件","text":"前言字节码文件是Java程序运行的载体，想要理解Java程序运行的原理，了解字节码文件的内容是重要的一步。最近小小地研究了一下字节码文件中究竟有什么奥秘。 查看字节码使用javap对class文件进行反编译，即可查看字节码文件的内容或者使用vscode中的HexDump插件，可以直接以十六进制的形式查看原始的二进制字节码文件 字节码文件格式字节文件中包含魔数、次版本号、主版本号、常量池、常量池 魔数与版本号魔数唯一的作用是识别文件是否是一个能被JVM接受的Class文件。次版本号和主版本号都是用于识别当前的JDK版本。高版本JDK能向下兼容旧版本的Class文件。 常量池与常量池容量常量池用于存储字面量（Literal）和符号引用（SymbolicReferences）。 字面量字面量接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。 符号引用符号引用包括下面三类常量 类与接口的全限定名（Fully Qualified Name） 字段的名称和描述符（Descriptor） 方法的名称和描述符 常量池中的每一项常量都是一中类似列表的数据结构，其首位存储标志位，用于标记是什么类型的常量，紧接着的数据由不同的常量结构来决定常量池中存储的信息有： 各类型基本及字符串数据字面量 字段、类、接口、字段或方法的部分符号引用 方法句柄 方法类型标识 动态方法调用点 这里有几个点可以关注一下： CONSTANT_String_info常量标识String的字面量，其结构大致可表示如下： 1234CONSTANT_String_info { u1 tag; u2 string_index; } 其并不直接存储字符串数据，只保存了常量池索引，索引会指向另一个CONSTANT_Utf8_info常量，这个才是存储字符串数据的常量。 CONSTANT_Utf8_info常量的结构大致可表示如下： 12345678910CONSTANT_Utf8_info { u1 tag; u2 length; u1 bytes; u1 bytes; u1 bytes; . . .(bytes数据有length个)} length值说明了这个UTF-8编码的字符串长度是多少字节，它后面紧跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串。由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名称，故CONSTANT_Utf8_info型常量的最大长度就是Java中方法、字段名的最大长度。又由于u2类型能表达的最大值为65535，所以Java程序中定义了超过64KB英文字符的变量或方法名，将会无法编译。同理，由字符串字面量的定义可知，在编译期，理论上字符串长度最大为65535，而由于javac程序的范围判断（具体可查看javac源码，是&gt;与&gt;=的区别），最大长度实际上是65534。 访问标志(access_flags)在常量池结束后的数据是访问标志，用于标识类或接口层层的访问信息，比如这个Class是接口还是类，是否定义为public，是否定义为abstract等。 类索引、父类索引与接口索引集合用来描述类的继承信息的数据，索引会指向常量池，找出对应的类名、接口名、父类名（均为全限定名） 字段表集合(field_info)用于描述接口或类中声明的变量的数据，其中包括变量的作用域、是实例变量还是类变量（static）、可变性（final）、并发可见性（violatile）、可否被序列化（transient）、字段数据类型、字段名称等。access_flags是描述符列表，name_index和descriptior_index都是对常量池的引用，分别代表字段的简单名称和描述符。描述符的作用是用来描述字段的数据类型、方法的参数列表和返回值。 方法表集合（method_info）方法表集合与字段表集合的声明方式几乎一致，只是方法不能用volatile修饰和transient修饰，所以方法表集合中的access_flags中不会出现这两个标志，与之对应的是多了synchronized、abstract标志。","link":"/2021/01/24/2021-01-24-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6/"},{"title":"【阅读笔记】深入理解JVM虚拟机：第三章","text":"对象已死？ 1.垃圾回收算法介绍 引用计数算法 很难解决对象间相互循环引用的问题，当外部没有引用时无法GC 可达性分析算法 通过GC Roots作为起始点集，根据与GC Roots是否有引用链相连来判断是否需要回收 可作为GC Roots的对象： 线程间共享的元数据（如方法区里的对象） 线程启动以来的方法调用栈（如虚拟机栈和本地方法栈里引用的对象） 2.再谈引用 强引用 普通的引用赋值 只要存在强引用关系就不会GC 软引用 有用但非必须 系统将要OOM前会进行回收 弱引用 比软引用更弱的引用 被弱引用关联的对象在下一次GC时就会被回收 虚引用 设置虚引用只是为了其在GC时收到一个系统通知，不会对其他生存时间构成影响，也不能通过虚引用获取实例对象 3.生存还是死亡？ 可达性算法分析为不可达后的处理过程 P186 概述：不可达对象不会被立即回收，可以最多一次使用系统调用的finalize()方法重新建立引用来自救 垃圾收集算法1.标记-清除算法 标记需要回收的内存，直接进行清除 缺点：标记和清除的执行效率会随对象数量增长而降低；会产生大量不连续的内存碎片 2.标记-复制算法 回收新生代内存的优先选择 缺点：因为会进行复制，在对象存活率较高时效率会降低，一般不在老年代对象中使用 3.标记-整理算法 标记-&gt;将存货对象移动到内存空间另一端-&gt;清除存活边界以外的内存","link":"/2020/08/03/2020-08-03-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"title":"springboot启动流程源码解析","text":"好好啃一下这块硬骨头 前言虽然目前springboot目前已经迭代到2.5.x版本了，但鉴于springboot2.4.x版本后新增了springcloud的相关内容且相较于以前的版本代码风格有了比较大的变动，本文使用的springboot版本为2.3.9、JDK8版本。springboot的奥秘集中在三点：SpringApplication对象的创建，静态方法SpringApplication.run的执行以及一些关键注解的作用，所以本文会围绕这三点来进行源码分析。 1、构造SpringApplication对象main方法调用SpringApplication.run静态方法，并传入main方法所在的启动引导类SpringbootLearningApplicationApplication.class新建SpringApplication对象，并将引导类传入其构造方法然后进入第一个关键步骤，SpringApplication对象的创建。我们先来看下SpringApplication的构造方法。构造方法有两个参数，resourceLoader和primarySources，resourceLoader一般会置空，然后会在后续步骤中加载DefaultResourceLoader。primarySources是引导类，用于作为整个项目资源路径的引导标识，目前暂时还没见过有传多个引导类的情况。然后开始进行spring应用的资源初始化。-. 首先是应用类别判断。WebApplicationType.deduceFromClasspath()方法通过ClassUtils.isPresent方法判断当前ClassLoader中是否存在相应的类来决定应该初始化哪种类型的应用，如果我们引入了springboot-starter-web模块，则web应用都类型是SERVLET，本文也是基于这个类型来进行分析。-. 其次是各种资源的加载。在这里我们要重点关注getSpringFactoriesInstances方法，后面的ApplicationContextInitializer和ApplicationListener都是通过该方法进行加载的。initializers和listeners都是在此处进行赋值，便于后续spring容器刷新时对相应的对象做处理（回调）。getSpringFactoriesInstances方法会调起SpringFactoriesLoader.loadFactoryNames()方法，最终调用loadSpringFactories()方法，这个方法是Spring提供的SPI机制的实现。SpringFactoriesLoader类会在第一次调用loadSpringFactories方法时扫描当前ClassLoader所处理的路径下所有META-INF/spring.factories文件的配置信息，来找到需要加载到Spring容器中的类，并缓存起来。这里的ClassLoader是ApplicationClassLoader，会加载用户类路径上的类库，具体可以参考这篇文章：《JVM类加载机制》。简单来说，就是通过查找用户路径类库中的META-INF/spring.factories文件，来找到需要加载到Spring容器中的类，如果我们需要在这些扩展点进行扩展，只需要将自定义的类按照Spring的SPI规范进行编写，便可以将类在启动阶段载入到SpringApplication对象中。springboot在启动流程的扩展机制，基本上都是使用这种方式进行的。这里我们要搞清楚一个概念，和我们平时理解的工厂模式不同，虽然这个方法名叫做getSpringFactoriesInstances，但最终拿到的东西并不是一系列工厂实例集合，不是很清楚为什么要这样子命名。-. 最后的deduceMainApplicationClass()是用来记录引导类的信息的，暂时没有什么很大作用。 至此，一个SpringApplication对象就构建完成了。 2、SpringApplication.runSpringApplication对象构建完后，接下来就该让它跑起来了。在run方法中，有一些步骤我们没有必要去了解，这里我们只去关心有意义的步骤（比如设置显示器配置这种步骤我们直接略过就好）。 首先是进行监听器的初始化。这里的监听器和上面提到的监听器不同，实现的是SpringApplicationRunListener接口。我们可以深入以下两行代码看下其中的逻辑。 12SpringApplicationRunListeners listeners = getRunListeners(args);listeners.starting(bootstrapContext, this.mainApplicationClass); getRunListeners方法还是Spring提供的一个SPI扩展点，在底层还是去读取META-INF/spring.factories来读取SpringApplicationRunListener，与其他的扩展机制并无二致，只不过在外部进行了一层封装，将所有的SpringApplicationRunListener封装为一个SpringApplicationRunListeners对象。这里一般也不会有太多扩展，可以看到这里只加载了一个EventPublishRunListener，用于进行Spring应用启动的事件发布。然后是下面这个starting方法。这里必须得吐槽一下，在2.4.x版本，springboot有很多代码在2.4.0版本后这个方法完全用lamda表达式重写了一遍，不得不说可读性是真的一般。这些改动主要是为了增加SpringCloud的相关支持，和一般的springboot应用启动流程起始并不是很相关。最开始我看的是2.4.2版本的代码，属实难顶，这也是为什么在前言中建议只想学习springboot启动流程的话可以去看2.3.x的代码。 starting方法很简单，就是将所有listener遍历并进行事件发布。由于一般SpringApplicationRunListener的实现类只有EventPublishingRunListener，所以我们可以进一步查看这个类的代码。EventPublishingRunListener会构造一个SimpleApplicationEventMulticaster事件广播器，并将SpringApplication对象在构造方法中加载的Listener缓存在广播器中，并在starting方法会广播一个ApplicationStartingEvent，剩下的就是将事件广播给在onApplication方法中监听了这个事件的监听器了。详细步骤可以去阅读SimpleApplicationEventMulticaster的代码。所以如果我们要对spring启动监听器进行扩展，只需要按上面提到的SpringSPI方式将监听器注册到SpringApplication对象中（注意，不是容器哦，Spring容器到目前为止还没有进行创建），就可以对这些扩展点事件进行监听并执行相应的操作了。 接下来是进行配置环境的加载，就是根据一定的优先级去进行各个配置源的信息读取。各个步骤底层会涉及非常多的读取解析逻辑，但是这些步骤Springboot除了扩展点外和Spring并没有太大区别，我们就不深入到底层代码中去探索了，可以简略的看下关键步骤做的事情。Spring应用的环境配置由ConfigurableEnvironment对象负责处理，配置的步骤在SpringApplication#prepareEnvironment方法中 12345678910111213141516171819private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments) { // Create and configure the environment // 创建ConfigurableEnvironment实例 ConfigurableEnvironment environment = getOrCreateEnvironment(); // 将启动参数绑定到ConfigurableEnvironment中 configureEnvironment(environment, applicationArguments.getSourceArgs()); ConfigurationPropertySources.attach(environment); // springboot通过广播ApplicationEnvironmentPreparedEvent事件设置了一个扩展点 // 如果我们需要在环境准备阶段进行扩展，比如以微服务方式通过配置中心读取配置等，可以在这一步添加监听器来进行扩展 listeners.environmentPrepared(bootstrapContext, environment); bindToSpringApplication(environment); // 自定义的EnvironmentConverter配置和解析，比较少用 if (!this.isCustomEnvironment) { environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment, deduceEnvironmentClass()); } ConfigurationPropertySources.attach(environment); return environment;} 2.1 createApplicationContext下一个关键的步骤就是容器创建了，这里值得我们再细分几步来分析。Spring容器的相关知识可以参考我的另一篇文章《SpringIoc》首先，会通过反射的方式根据应用类型来创建容器类型实例，这里返回的容器类型是AnnotationConfigServletWebServerApplicationContext，然后会强制转换为ConfigurableApplicationContext下一步加载exceptionReporters是通过SPI扩展的方式加载SpringBootExceptionReporter，这里主要是用于对springboot应用启动时发生的错误进行处理的，我们一般也不会去做太多的扩展，exceptionReporters也不会进入到容器中，在此我们不做深入分析 12exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[] { ConfigurableApplicationContext.class }, context); 2.2 prepareContext在容器实例创建好后，接着进行容器装配的准备工作。我们可以逐步分析一下其中的关键步骤。 12345678910111213141516171819202122232425262728293031323334353637private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) { context.setEnvironment(environment); // 容器初始化后置处理，这一步会通过单利模式在容器的BeanFactory中预支ApplicationConversionService，用于进行各种数据转换处理 postProcessApplicationContext(context); // 应用容器初始化器，详情可看下文 applyInitializers(context); // 广播容器准备事件，同样，如果监听器需要在这一步执行操作，就可以监听这一事件 listeners.contextPrepared(context); // 日志打印，打印进程和应用的信息 if (this.logStartupInfo) { logStartupInfo(context.getParent() == null); logStartupProfileInfo(context); } // Add boot specific singleton beans ConfigurableListableBeanFactory beanFactory = context.getBeanFactory(); // 注册特殊bean：命令行参数对象 beanFactory.registerSingleton(\"springApplicationArguments\", applicationArguments); // 注册特殊bean：springboot logo打印对象 if (printedBanner != null) { beanFactory.registerSingleton(\"springBootBanner\", printedBanner); } // 设置是否允许同名的bean中后发现的覆盖先发现的，通过spring.main.allow-bean-definition-overriding配置，默认为true if (beanFactory instanceof DefaultListableBeanFactory) { ((DefaultListableBeanFactory) beanFactory) .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); } // 设置bean是否全局懒加载，通过spring.main.lazy-initialization篇日志，默认为false if (this.lazyInitialization) { context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor()); } // Load the sources Set&lt;Object&gt; sources = getAllSources(); Assert.notEmpty(sources, \"Sources must not be empty\"); load(context, sources.toArray(new Object[0])); listeners.contextLoaded(context); } 其中，applyInitializers(context)这一步，在前文提到的，在SpringApplication实例构造阶段，spring会通过SPI机制加载ApplicationContextInitializer容器初始化器，这些初始化器在这一个步骤就会被启用，并在容器刷新前对容器进行必要的配置。如果我们编写的组件需要在容器刷新前进行必要的配置，那我们就可以通过容器初始化器来实现这个步骤。 接着就是重中之重，容器的刷新（refreshContext）了。逐步递进，refreshContext操作最终会进入到接口ConfigurableApplicationContext的refresh方法中并且由AbstractApplicationContext实现，这个方法使用了模板方法模式，定义了操作中的各个抽象步骤并且由子类进行具体实现，我们可以看下这个方法都做了什么。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try { // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); } } } 我们来逐步的分析一下refresh方法做了什么。由于本文中的应用类型是SERVLET，故AbstractApplicationContext中的抽象方法都是由AnnotationConfigServletWebServerApplicationContext来进行实现的。 prepareRefresh(); prepareRefresh方法设置容器启动时间和活动标志，以及通过调用initPropertySources()方法完成所有的property资源的初始化。总结下来，这一步没有做什么很重要的操作 1234567891011121314151617181920212223242526272829303132333435363738394041protected void prepareRefresh() { // Switch to active. this.startupDate = System.currentTimeMillis(); // 设置容器状态 this.closed.set(false); this.active.set(true); if (logger.isDebugEnabled()) { if (logger.isTraceEnabled()) { logger.trace(\"Refreshing \" + this); } else { logger.debug(\"Refreshing \" + getDisplayName()); } } // Initialize any placeholder property sources in the context environment. // 初始化property sources，但一路debug发现里面什么也没做（所有判断条件均跳过了），暂时不清楚里面做了什么 initPropertySources(); // Validate that all properties marked as required are resolvable: // see ConfigurablePropertyResolver#setRequiredProperties // 校验是否所有必须的配置项都已配置好了 getEnvironment().validateRequiredProperties(); // Store pre-refresh ApplicationListeners... // 将SpringApplication实例初始化过程中加载的监听器添加到容器中，并标记为earlyApplicationListeners if (this.earlyApplicationListeners == null) { this.earlyApplicationListeners = new LinkedHashSet&lt;&gt;(this.applicationListeners); } else { // Reset local application listeners to pre-refresh state. this.applicationListeners.clear(); this.applicationListeners.addAll(this.earlyApplicationListeners); } // Allow for the collection of early ApplicationEvents, // to be published once the multicaster is available... // 意义不明 this.earlyApplicationEvents = new LinkedHashSet&lt;&gt;(); } ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); 获取beanFactory。在obtainFreshBeanFactory()中有两步，refreshBeanFactory()和getBeanFactory(); 1234protected ConfigurableListableBeanFactory obtainFreshBeanFactory() { refreshBeanFactory(); return getBeanFactory();} refreshBeanFactory()方法由GenericApplicationContext实现，在其中spring并没有做任何容器相关的操作，但是通过compareAndSet操作来保证beanFactory只会别刷新一次，可以查看这个方法的注释 12345678910111213/** * Do nothing: We hold a single internal BeanFactory and rely on callers * to register beans through our public methods (or the BeanFactory's). * @see #registerBeanDefinition */@Overrideprotected final void refreshBeanFactory() throws IllegalStateException { if (!this.refreshed.compareAndSet(false, true)) { throw new IllegalStateException( \"GenericApplicationContext does not support multiple refresh attempts: just call 'refresh' once\"); } this.beanFactory.setSerializationId(getId());} beanFactory早在GenericApplicationContext的构造方法就已完成实例创建。在注释中提到，bean是只会通过registerBeanDefinition方法来注册的，所以在目前这一步刷新beanFactory的操作还不会进行bean的注册。 prepareBeanFactory(beanFactory); 在这一步中，会将各种bean注册所必须的资源添加到beanFactory中，使beanFactory拥有注册bean的能力。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) { // Tell the internal bean factory to use the context's class loader etc. // 设置类加载器 beanFactory.setBeanClassLoader(getClassLoader()); // 设置el表达式解析器 beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); // 设置配置属性解析器 beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment())); // Configure the bean factory with context callbacks. // 将ApplicationContextAwareProcessor添加到后置处理器列表 beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); // 忽略下列接口的自动装配（为什么要忽略？） beanFactory.ignoreDependencyInterface(EnvironmentAware.class); beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class); beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class); beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class); beanFactory.ignoreDependencyInterface(MessageSourceAware.class); beanFactory.ignoreDependencyInterface(ApplicationContextAware.class); // BeanFactory interface not registered as resolvable type in a plain factory. // MessageSource registered (and found for autowiring) as a bean. // 指定下列接口注入时使用当前的beanFactory和容器实现类来进行注入 beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory); beanFactory.registerResolvableDependency(ResourceLoader.class, this); beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this); beanFactory.registerResolvableDependency(ApplicationContext.class, this); // Register early post-processor for detecting inner beans as ApplicationListeners. // 将ApplicationListenerDetector添加到后置处理器列表 beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this)); // Detect a LoadTimeWeaver and prepare for weaving, if found. // 如果配置了LTW（一种代码织入器）的话，就将其添加到后置处理 if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) { beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); // Set a temporary ClassLoader for type matching. beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); } // Register default environment beans. // 将环境配置注册为bean if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) { beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment()); } // 将系统配置注册为bean if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) { beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties()); } // 将系统环境注册为bean if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) { beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment()); }} invokeBeanFactoryPostProcessors(beanFactory) 这一步是向beanFactory中实例化BeanFactoryPostProcessor。BeanFactoryPostProcessor是spring为我们提供的一个扩展点，允许我们在bean初始化前获得并修改bean的元信息。 1234567891011protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) { // 获取beanFactoryPostProcessor。在这里，通过getBeanFactoryPostProcessors()方法可以拿到三个预置的beanFactoryPostProcessor，这些都是在之前通过初始化器和监听器在容器准备阶段完成初始化的。 PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor) if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) { beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); }} 我们可以进一步进入PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors())方法。 这个方法非常长，我们可以只关注关键的几步。","link":"/2021/02/23/2021-02-10-springboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/"},{"title":"理解springioc（一）：一个基本的bean容器——DefaultListableBeanFactory","text":"前言BeanFactory是Spring中最核心的接口。它为我们定义了从容器中获取bean的方法。如果说容器是一间房子，那么BeanFactory就是我们进入这间房子的大门。而DefaultListableBeanFactory就是一个默认的、最常用的BeanFactory实现类，本文我们就通过DefaultListableBeanFactory来一窥spring容器的奥秘。 DefaultListableBeanFactoryDefaultListableBeanFactory位于org.springframework.beans.factory.support包下DefaultListableBeanFactory是一个最基本的能真正实例化bean的一个BeanFactory实现类，同时实现了BeanDefinitionRegistry和BeanFactory接口。我们可以通过了解DefaultListableBeanFactory的工作原理来理解一个bean是怎么被加载的。注意，本文首先是通过一个全局的视角来抽象地认识一个bean容器，并不会去深入研究具体的实现原理，所以下文我们都是直接从接口的定义来认识bean容器，而不会探究其实现原理。 DefaultListableBeanFactory的类关系图如下其中处于顶层的类关系有这么几个： 1. 获取bean的门面接口：实现BeanFactory接口BeanFacatory位于org.springframework.beans.factory包下。它是顶层的ioc容器接口，所有ioc容器的实现均需要实现该接口。它是获取bean的门面接口，容器的使用者通过该接口来获取bean或是获取bean的关键信息。 BeanFactory接口方法 12345678910111213141516171819202122232425262728293031323334353637public interface BeanFactory { String FACTORY_BEAN_PREFIX = \"&amp;\"; Object getBean(String name) throws BeansException; &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException; Object getBean(String name, Object... args) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException; &lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(Class&lt;T&gt; requiredType); &lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(ResolvableType requiredType); boolean containsBean(String name); boolean isSingleton(String name) throws NoSuchBeanDefinitionException; boolean isPrototype(String name) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException; @Nullable Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException; @Nullable Class&lt;?&gt; getType(String name, boolean allowFactoryBeanInit) throws NoSuchBeanDefinitionException; String[] getAliases(String name);} BeanFactory的方法不难理解，定义的大多是获取bean实例或是bean的相关信息的方法。FACTORY_BEAN_PREFIX则是用来标记要获取的是FactoryBean而非FactoryBean生产的bean。由于BeanFactory的具体实现方法还涉及到Spring的其他扩展功能，在此我们先抽象的感受一下BeanFactory的方法即可。 2. 注册bean元信息：实现BeanDefinitionRegistry接口BeanDefinitionRegistry位于org.springframework.beans.factory.support包下。在spring中，bean通常通过xml文件或者JavaConfig的方式进行定义，每个bean的定义信息（如bean的作用于、bean是否懒加载等）会由一个相应的BeanDefinition对象来进行存储。而BeanDefinition则会通过BeanDefinitionRegistry注册到容器中，这样容器才能根据配置信息生成一个bean。至于从配置文件转换为BeanDefiniton的工作，则是由ClassPathBeanDefinitionScanner来进行收集、BeanDefinitionReader来进行解析的。此处我们仅需要知道有这两个角色即可，不作展开。我们可以先看下BeanDefinitionRegistry定义的方法 BeanDefinitionRegistry接口方法 123456789101112131415161718192021222324public interface BeanDefinitionRegistry extends AliasRegistry { // 关键 -&gt; 向注册表中注册一个新的BeanDefinition实例 void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException; // 移除注册表中已注册的BeanDefinition实例 void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException; // 从注册中心取得指定的BeanDefinition实例 BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException; // 判断BeanDefinition实例是否在注册表中（是否注册） boolean containsBeanDefinition(String beanName); // 取得注册表中所有BeanDefinition实例的beanName（标识） String[] getBeanDefinitionNames(); // 返回注册表中BeanDefinition实例的数量 int getBeanDefinitionCount(); // beanName（标识）是否被占用 boolean isBeanNameInUse(String beanName);} 其中最关键的是registerBeanDefinition(String beanName, BeanDefinition beanDefinition)方法，容器通过这个方法将bean的元信息BeanDefinition添加到注册表中。而在DefaultListableBeanFactory中，BeanDefinition注册表是通过一个线程安全的ConcurrentHashMap来实现的。 12/** Map of bean definition objects, keyed by bean name. */private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256); 同样，BeanDefinition还有很多不同的实现类，扩展了很多注册BeanDefinition的方法，在此我们依然是先抽象地感受一下这个类的方法即可。 3. 单例bean的注册中心：实现SingletonBeanRegistry接口SingletonBeanRegistry位于org.springframework.beans.factory.config包下。它是单例Bean的注册中心。与BeanDefinitionRegistry不同，BeanDefinitionRegistry用于注册元信息（BeanDefinition），而SingletonBeanRegistry则是真正向容器中注册一个单例的bean。当我们从容器中获取单例bean时，底层就是使用SingletonBeanRegistry来获取单例bean。 SingletonBeanRegistry 1234567891011121314151617181920public interface SingletonBeanRegistry { // 向Bean容器中注册单例Bean void registerSingleton(String beanName, Object singletonObject); // 根据Bean的名字获取单例Bean @Nullable Object getSingleton(String beanName); // 根据Bean的名字判断容器中是否存在单例Bean boolean containsSingleton(String beanName); // 获取容器中所有的单例Bean的名字 String[] getSingletonNames(); // 获取容器中单例Bean的数量 int getSingletonCount(); // 返回此注册表使用的单例互斥锁 Object getSingletonMutex();} 这里有两个方法比较关键，注册单例bean的方法void registerSingleton(String beanName, Object singletonObject)和获取单例bean的方法Object getSingleton(String beanName)。Spring在启动过程中会使用三个map（亦被称之为三级缓存）来进行bean的存储。 1234567891011/** Cache of singleton objects: bean name to bean instance. */// 一级缓存，以bean的名字为key，bean实例为valueprivate final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);/** Cache of singleton factories: bean name to ObjectFactory. */// 三级缓存，以bean的名字为key，创建bean的工厂为valueprivate final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16);/** Cache of early singleton objects: bean name to bean instance. */// 二级缓存，以bean的名字为key，早期bean实例为value（早期bean是未构建完全的bean，实际上是不可用的，只是用来解决循环依赖的问题）private final Map&lt;String, Object&gt; earlySingletonObjects = new ConcurrentHashMap&lt;&gt;(16); 这里我们可以稍微发散一下，先来看一下SingletonBeanRegistry最常用的实现类DefaultSingletonBeanRegistry是如何实现这两个方法的。 3.1 registerSingleton 123456789101112131415161718192021222324@Overridepublic void registerSingleton(String beanName, Object singletonObject) throws IllegalStateException { Assert.notNull(beanName, \"Bean name must not be null\"); // 利用单例注册表的方式来保证bean是单例注册的。 Assert.notNull(singletonObject, \"Singleton object must not be null\"); synchronized (this.singletonObjects) { Object oldObject = this.singletonObjects.get(beanName); if (oldObject != null) { throw new IllegalStateException(\"Could not register object [\" + singletonObject + \"] under bean name '\" + beanName + \"': there is already object [\" + oldObject + \"] bound\"); } addSingleton(beanName, singletonObject); }}protected void addSingleton(String beanName, Object singletonObject) { synchronized (this.singletonObjects) { // 无论二、三级缓存是否存在bean，都会将其清空，并升级到一级缓存中，同时beanName添加到已注册列表中 this.singletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); this.earlySingletonObjects.remove(beanName); this.registeredSingletons.add(beanName); }} 3.2 getSingleton 123456789101112131415161718192021222324252627282930313233@Nullableprotected Object getSingleton(String beanName, boolean allowEarlyReference) { // Quick check for existing instance without full singleton lock // 尝试从一级缓存中获取单例bean Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) { // 如果一级缓存中不存在bean，且bean的状态为创建中，则从二级缓存中获取早期的单例bean singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null &amp;&amp; allowEarlyReference) { // 如果二级缓存中也不存在bean，且spring允许循环依赖（allowEarlyReference，默认为true），则会开始通过单例注册表的方式来进行单例bean的创建 synchronized (this.singletonObjects) { // Consistent creation of early reference within full singleton lock // 检查一级缓存 singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) { // 检查二级缓存 singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null) { // 检查三级缓存 ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName); // 如果三级缓存不为空，则从对应的单例bean工厂中创建早期bean实例，并将其放入二级缓存中，同时，将三级缓存中的bean工厂删除。 if (singletonFactory != null) { singletonObject = singletonFactory.getObject(); this.earlySingletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); } } } } } } return singletonObject;} 当然，我们一般不会直接调用这两个接口来进行单例bean的注册和获取，但是在spring中单例bean的注册和获取（BeanFactory的getBean方法）最终还是会回到这两个方法上，所以我们对这两个方法的学习还是有必要的。 4. 其他：bean的别名管理类：继承SimpleAliasRegistry -&gt; 实现AliasRegistry接口；支持序列化：实现Serializable序列化接口第四4相对来说没有那么重要，此处先跳过。如果一个容器实现了BeanDefinitionRegistry、BeanFactory、SingletonBeanRegistry，那么就已经具备了一个容器的必要的功能了。我们是可以直接使用DefaultListableBeanFactory来实现一个bean的注册和获取的。 bean容器实战定义一个实体类 12345678public class MyBean { private final Logger logger = LoggerFactory.getLogger(MyBeanA.class); public void test() { logger.info(\"myBean is testing!\"); }} 编写一个启动类 123456789101112131415161718@ComponentScanpublic class BootStrap { public static void main(String[] args) { // 此处我们先新建一个高级容器AnnotationConfigApplicationContext，免去很多初始化过程，我们只需知道这是一个支持注解的高级容器即可 AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(BootStrap.class); // 获取基本的DefaultListableBeanFactory DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory) applicationContext.getBeanFactory(); // 创建一个基本的BeanDefinition——GenericBeanDefinition，并将MyBean转换为BeanDefinition GenericBeanDefinition beanDefinition = new GenericBeanDefinition(); beanDefinition.setBeanClass(MyBean.class); // 在容器中注册BeanDefiniton beanFactory.registerBeanDefinition(\"myBean\", beanDefinition); // 获取并调用bean的方法 MyBean myBean = (MyBean) beanFactory.getBean(\"myBean\"); myBean.test(); }} 启动main方法，顺利地执行了myBean的test方法 12345678923:17:33.469 [main] DEBUG org.springframework.context.annotation.AnnotationConfigApplicationContext - Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@4850386823:17:33.491 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.annotation.internalConfigurationAnnotationProcessor'23:17:33.565 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.event.internalEventListenerProcessor'23:17:33.568 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.event.internalEventListenerFactory'23:17:33.570 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.annotation.internalAutowiredAnnotationProcessor'23:17:33.572 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'org.springframework.context.annotation.internalCommonAnnotationProcessor'23:17:33.582 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'bootStrap'23:17:33.609 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Creating shared instance of singleton bean 'myBean'23:17:33.610 [main] INFO cn.com.xvym.learning.springbootlearning.MyBean - myBean is testing! 这就是一个最基本的bean的注册和获取过程。当然，我们常用的bean注册方式肯定不会是这么繁琐的，spring通过很多另外的接口扩展功能为我们实现了更为方便的bean注册和获取方式和很多bean的增强功能，但是底层最终还是会调用到这几个基本的方法，这些我们可以在后面再持续进行探讨。","link":"/2021/01/28/2021-01-28-%E7%90%86%E8%A7%A3springioc%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84bean%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94DefaultListableBeanFactory/"},{"title":"2021-01-30-理解springioc（二）：认识spring的高级容器","text":"前言在《理解springioc（一）：一个基本的bean容器——DefaultListableBeanFactory》一文中，我们初步认识了一个关键的基础容器——DefaultListableBeanFactory，而spring中的高级容器往往都会使用DefaultListableBeanFactory来作为BeanFactory。在本文中，我们就来更逐步地探讨一下spring中的高级容器。 ApplicationContextApplicationContext是BeanFactory的一个扩展，该接口除了拥有BeanFactory的所有功能外，还具有以下扩展： 继承MessageSource，用于支撑国际化功能 继承ApplicationEventPublisher，提供Spring的事件机制 继承ResourceLoader，用于加载资源文件 继承EnvironmentCapable，用于获取Environment对象进而支持多环境配置 在ApplicationContext中新定义了以下的方法 ApplicationContext接口方法 123456789101112131415161718192021222324public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver { // 获取ApplicationContext的id @Nullable String getId(); // 获取ApplicationContext的名字 String getApplicationName(); // 获取一个便于查看的ApplicationContext的名字 String getDisplayName(); // 获取ApplicationContext的启动日期 long getStartupDate(); // 获取ApplicationContext的父容器 @Nullable ApplicationContext getParent(); // 将AutowireCapableBeanFactory暴露给外部使用，一般比较少使用，此处先略过 AutowireCapableBeanFactory getAutowireCapableBeanFactory() throws IllegalStateException;} 可以看到，这些方法只定义了对ApplicationContext一些信息获取的方法，其功能扩展是通过集成更多的接口来达成的。 比较ApplicationContext和DefaultListableBeanFactory的类图，我们可以看到ApplicationContext并没有去实现SingletonBeanRegistry和BeanDefinitionRegistry等接口，这与我们在上一篇文章中认为的容器应该实现这些接口有出入。我们可以带着这些疑问继续往下看。 ConfigurableApplicationContext、WebApplicationContext和ConfigurableWebApplicationContextApplicationContext接口有两个直接子接口，ConfigurableApplicationContext和WebApplicationContext，在此之上，还有一个继承了这两个子接口的ConfigurableWebApplicationContext。我们可以通过ConfigurableWebApplicationContext的类图来了解这些接口的联系我们可以直接看下这三个类的代码 1. ConfigurableApplicationContext接口相较于Application，ConfigurableApplicationContext接口又多了以下的扩展：2. 实现Lifecycle接口，用于管理容器的生命周期3. 实现Closeable，用于关闭资源。 该接口在ApplicationContext的基础上增加了很多配置容器的方法，并将配置容器、控制容器生命周期的方法进行了封装，避免直接调用底层的EnvironmentCapable接口和Lifecycle接口。 ConfigurableApplicationContext接口方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public interface ConfigurableApplicationContext extends ApplicationContext, Lifecycle, Closeable { // spring规定的用于分割配置文件路径的符号（ConfigurableApplicationContext支持读取多个配置文件） String CONFIG_LOCATION_DELIMITERS = \",; \\t\\n\"; // 下方几个定义的XX_NAME静态变量是Spring中规定的特殊bean的名字，spring只会利用这些名字去取相应的bean String CONVERSION_SERVICE_BEAN_NAME = \"conversionService\"; String LOAD_TIME_WEAVER_BEAN_NAME = \"loadTimeWeaver\"; String ENVIRONMENT_BEAN_NAME = \"environment\"; String SYSTEM_PROPERTIES_BEAN_NAME = \"systemProperties\"; String SYSTEM_ENVIRONMENT_BEAN_NAME = \"systemEnvironment\"; String SHUTDOWN_HOOK_THREAD_NAME = \"SpringContextShutdownHook\"; // 设置容器id void setId(String id); // 设置父容器id void setParent(@Nullable ApplicationContext parent); // 设置环境对象 void setEnvironment(ConfigurableEnvironment environment); // 重写继承自EnvironmentCapable的getEnvironment方法，返回可配置的环境对象 @Override ConfigurableEnvironment getEnvironment(); // 向容器中添加BeanFactoryPostProcessor，会在读取容器配置的时候调用，增加的Processor会在容器refresh的时候使用 void addBeanFactoryPostProcessor(BeanFactoryPostProcessor postProcessor); // 向容器增加一个ApplicationListener，如果容器还没有启动，那么在此增加的监听器将会在refresh中全部被调用，如果容器已经是active状态，则会通过multicaster中通过广播的方式进行调用 void addApplicationListener(ApplicationListener&lt;?&gt; listener); // 设置类加载器，这个类加载器会传递到内部bean工厂 void setClassLoader(ClassLoader classLoader); // 向容器中增加ProtocolResolver，用于解析协议 void addProtocolResolver(ProtocolResolver resolver); // 高级容器的重中之重，加载资源配置文件，刷新容器并初始化所有的bean，在refresh方法执行完毕后，要么所有的bean都完成了初始化，要么就一个都没有完成初始化 void refresh() throws BeansException, IllegalStateException; // 向JVM注册一个回调函数，用以在JVM关闭时销毁容器 void registerShutdownHook(); // 关闭容器，释放所有的资源和锁并销毁所有缓存的singletonBean。spring的注释中提到，不要去调用其父类容器的close方法，父类容器有其自己的生命周期。 @Override void close(); // 检测该容器是否被启动过 boolean isActive(); // 返回此容器的BeanFactory，注意不要通过该方法来对容器中的bean进行处理，因为单例bean在此之前已经生成 ConfigurableListableBeanFactory getBeanFactory() throws IllegalStateException;} WebApplicationContext接口方法 1234567891011121314151617181920public interface WebApplicationContext extends ApplicationContext { String ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE = WebApplicationContext.class.getName() + \".ROOT\"; String SCOPE_REQUEST = \"request\"; String SCOPE_SESSION = \"session\"; String SCOPE_APPLICATION = \"application\"; String SERVLET_CONTEXT_BEAN_NAME = \"servletContext\"; String CONTEXT_PARAMETERS_BEAN_NAME = \"contextParameters\"; String CONTEXT_ATTRIBUTES_BEAN_NAME = \"contextAttributes\"; @Nullable ServletContext getServletContext();}","link":"/2021/01/30/2021-01-30-%E7%90%86%E8%A7%A3springioc%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%AE%A4%E8%AF%86spring%E7%9A%84%E9%AB%98%E7%BA%A7%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"other","slug":"other","link":"/tags/other/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"reading","slug":"reading","link":"/tags/reading/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"}],"categories":[{"name":"other","slug":"other","link":"/categories/other/"},{"name":"reading note","slug":"reading-note","link":"/categories/reading-note/"},{"name":"article","slug":"article","link":"/categories/article/"}]}