{"pages":[{"title":"","text":"xvym.github.ioXv’s blog.","link":"/README.html"}],"posts":[{"title":"Hello World!","text":"2020-08-02搞了一下午终于把blog搞好了。挺好玩的，还有很多设置可以搞一搞。下面是Hexo官方自带的说明和一些基本操作。头像是我的爱猫大狗。 NotesWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/08/02/2020-08-02-hello-world/"},{"title":"【阅读笔记】深入理解JVM虚拟机：第二章","text":"Java内存区域与内存溢出异常 1.数据区域 1.1.运行时数据区域 线程共享 方法区(Method Area) 存储已被虚拟机加载的类型信息、常量、静态变量、JIT编译后的代码缓存等数据 常量池表位于该区域 无法满足新的内存分配需求时，抛出OOM异常 堆(Heap) 在虚拟机启动时创建，存放几乎所有的对象实例，垃圾收集器GC就作用于此 通过-Xmx和-Xms设定容量扩展 当内存容量不足以完成对象实例化时，会抛出OOM异常 线程私有（生命周期与当前线程相同） 虚拟机栈(VM Stack) 每个方法被执行时，虚拟机会同步创建一个栈帧（StackFrame），存储一个方法执行时的变量表、操作数栈、动态链接、方法出口等信息 每个方法被调用到执行完毕，就是一个栈帧从入栈到出栈的过程 若方法调用过深，导致栈帧累计内存超过-Xss，会抛出SOF异常 如果设置了栈内存动态扩展，当栈扩展超出内存容量时会抛出OOM异常 本地方法栈（Native Method Stack） 与虚拟机机栈的作用类似，区别是虚拟机栈为虚拟机执行Java方法服务，本地方法栈为虚拟机使用到的本地方法（Native）服务 异常抛出情况与虚拟机栈一致 程序计数器（Program Counter Register） 当前线程所执行的字节码的行号指示器 唯一一个不会OOM的区域 1.2.直接内存 非虚拟机运行数据区 JDK的NIO类可以使用Native函数库直接分配堆外内存，也会出现OOM 2.虚拟机对象探秘 对象的创建 虚拟机遇到字节码new指令时的处理过程——第七章详解 对象的布局 对象头(Header) 实例数据(InstanceData) 3.OOM异常 分析OOM 确认是内存泄漏(Memory Leak) 还是内存溢出(Menory OverFlow) ，分析内存映像。 扩展虚拟机内存设置 检查代码问题 虚拟机栈和本地方法栈溢出 制造溢出场景的方法：减少栈内存容量并通制造大量本地变量，增大次方法帧中的变量表长度2.使用默认参数时，HotSpot虚拟机的栈深度一般可以达到1000~2000 方法区和运行时常量池溢出","link":"/2020/08/02/2020-08-02-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"title":"我的书单","text":"阅读计划《spring-framework-reference》《Redis设计与实现》《Java并发编程的艺术》《Linux内核设计的艺术》《深入理解Kafka》《Go语言——从入门到进阶实战》《操作系统》 2020年阅读记录二月《Spring实战》 三月《SpringBoot揭秘：快速构建微服务体系》《SpringBoot开发实战》 四月None 五月《Python编程：从入门到实践》 六月《网络是怎样连接的》 七月《操作系统》——30% 八月《深入理解JVM虚拟机》","link":"/2020/08/02/2020-08-02-%E6%88%91%E7%9A%84%E4%B9%A6%E5%8D%95/"},{"title":"字节码文件","text":"前言字节码文件是Java程序运行的载体，想要理解Java程序运行的原理，了解字节码文件的内容是重要的一步。最近小小地研究了一下字节码文件中究竟有什么奥秘。 查看字节码使用javap对class文件进行反编译，即可查看字节码文件的内容或者使用vscode中的HexDump插件，可以直接以十六进制的形式查看原始的二进制字节码文件 字节码文件格式字节文件中包含魔数、次版本号、主版本号、常量池、常量池 魔数与版本号魔数唯一的作用是识别文件是否是一个能被JVM接受的Class文件。次版本号和主版本号都是用于识别当前的JDK版本。高版本JDK能向下兼容旧版本的Class文件。 常量池与常量池容量常量池用于存储字面量（Literal）和符号引用（SymbolicReferences）。 字面量字面量接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。 符号引用符号引用包括下面三类常量 类与接口的全限定名（Fully Qualified Name） 字段的名称和描述符（Descriptor） 方法的名称和描述符 常量池中的每一项常量都是一中类似列表的数据结构，其首位存储标志位，用于标记是什么类型的常量，紧接着的数据由不同的常量结构来决定常量池中存储的信息有： 各类型基本及字符串数据字面量 字段、类、接口、字段或方法的部分符号引用 方法句柄 方法类型标识 动态方法调用点 这里有几个点可以关注一下： CONSTANT_String_info常量标识String的字面量，其结构大致可表示如下： 1234CONSTANT_String_info { u1 tag; u2 string_index; } 其并不直接存储字符串数据，只保存了常量池索引，索引会指向另一个CONSTANT_Utf8_info常量，这个才是存储字符串数据的常量。 CONSTANT_Utf8_info常量的结构大致可表示如下： 12345678910CONSTANT_Utf8_info { u1 tag; u2 length; u1 bytes; u1 bytes; u1 bytes; . . .(bytes数据有length个)} length值说明了这个UTF-8编码的字符串长度是多少字节，它后面紧跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串。由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名称，故CONSTANT_Utf8_info型常量的最大长度就是Java中方法、字段名的最大长度。又由于u2类型能表达的最大值为65535，所以Java程序中定义了超过64KB英文字符的变量或方法名，将会无法编译。同理，由字符串字面量的定义可知，在编译期，理论上字符串长度最大为65535，而由于javac程序的范围判断（具体可查看javac源码，是&gt;与&gt;=的区别），最大长度实际上是65534。 访问标志(access_flags)在常量池结束后的数据是访问标志，用于标识类或接口层层的访问信息，比如这个Class是接口还是类，是否定义为public，是否定义为abstract等。 类索引、父类索引与接口索引集合用来描述类的继承信息的数据，索引会指向常量池，找出对应的类名、接口名、父类名（均为全限定名） 字段表集合(field_info)用于描述接口或类中声明的变量的数据，其中包括变量的作用域、是实例变量还是类变量（static）、可变性（final）、并发可见性（violatile）、可否被序列化（transient）、字段数据类型、字段名称等。access_flags是描述符列表，name_index和descriptior_index都是对常量池的引用，分别代表字段的简单名称和描述符。描述符的作用是用来描述字段的数据类型、方法的参数列表和返回值。 方法表集合（method_info）方法表集合与字段表集合的声明方式几乎一致，只是方法不能用volatile修饰和transient修饰，所以方法表集合中的access_flags中不会出现这两个标志，与之对应的是多了synchronized、abstract标志。","link":"/2021/01/24/2021-01-24-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6/"},{"title":"【阅读笔记】深入理解JVM虚拟机：第三章","text":"对象已死？ 1.垃圾回收算法介绍 引用计数算法 很难解决对象间相互循环引用的问题，当外部没有引用时无法GC 可达性分析算法 通过GC Roots作为起始点集，根据与GC Roots是否有引用链相连来判断是否需要回收 可作为GC Roots的对象： 线程间共享的元数据（如方法区里的对象） 线程启动以来的方法调用栈（如虚拟机栈和本地方法栈里引用的对象） 2.再谈引用 强引用 普通的引用赋值 只要存在强引用关系就不会GC 软引用 有用但非必须 系统将要OOM前会进行回收 弱引用 比软引用更弱的引用 被弱引用关联的对象在下一次GC时就会被回收 虚引用 设置虚引用只是为了其在GC时收到一个系统通知，不会对其他生存时间构成影响，也不能通过虚引用获取实例对象 3.生存还是死亡？ 可达性算法分析为不可达后的处理过程 P186 概述：不可达对象不会被立即回收，可以最多一次使用系统调用的finalize()方法重新建立引用来自救 垃圾收集算法1.标记-清除算法 标记需要回收的内存，直接进行清除 缺点：标记和清除的执行效率会随对象数量增长而降低；会产生大量不连续的内存碎片 2.标记-复制算法 回收新生代内存的优先选择 缺点：因为会进行复制，在对象存活率较高时效率会降低，一般不在老年代对象中使用 3.标记-整理算法 标记-&gt;将存货对象移动到内存空间另一端-&gt;清除存活边界以外的内存","link":"/2020/08/03/2020-08-03-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%89%E7%AB%A0/"}],"tags":[{"name":"other","slug":"other","link":"/tags/other/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"reading","slug":"reading","link":"/tags/reading/"}],"categories":[{"name":"other","slug":"other","link":"/categories/other/"},{"name":"reading note","slug":"reading-note","link":"/categories/reading-note/"},{"name":"article","slug":"article","link":"/categories/article/"}]}