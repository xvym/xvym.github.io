{"pages":[{"title":"","text":"xvym.github.ioXv’s blog.","link":"/README.html"}],"posts":[{"title":"Hello World!","text":"2020-08-02搞了一下午终于把blog搞好了。挺好玩的，还有很多设置可以搞一搞。下面是Hexo官方自带的说明和一些基本操作。头像是我的爱猫大狗。 NotesWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/08/02/2020-08-02-hello-world/"},{"title":"【阅读笔记】深入理解JVM虚拟机：第二章","text":"Java内存区域与内存溢出异常 1.数据区域 1.1.运行时数据区域 线程共享 方法区(Method Area) 存储已被虚拟机加载的类型信息、常量、静态变量、JIT编译后的代码缓存等数据 常量池表位于该区域 无法满足新的内存分配需求时，抛出OOM异常 堆(Heap) 在虚拟机启动时创建，存放几乎所有的对象实例，垃圾收集器GC就作用于此 通过-Xmx和-Xms设定容量扩展 当内存容量不足以完成对象实例化时，会抛出OOM异常 线程私有（生命周期与当前线程相同） 虚拟机栈(VM Stack) 每个方法被执行时，虚拟机会同步创建一个栈帧（StackFrame），存储一个方法执行时的变量表、操作数栈、动态链接、方法出口等信息 每个方法被调用到执行完毕，就是一个栈帧从入栈到出栈的过程 若方法调用过深，导致栈帧累计内存超过-Xss，会抛出SOF异常 如果设置了栈内存动态扩展，当栈扩展超出内存容量时会抛出OOM异常 本地方法栈（Native Method Stack） 与虚拟机机栈的作用类似，区别是虚拟机栈为虚拟机执行Java方法服务，本地方法栈为虚拟机使用到的本地方法（Native）服务 异常抛出情况与虚拟机栈一致 程序计数器（Program Counter Register） 当前线程所执行的字节码的行号指示器 唯一一个不会OOM的区域 1.2.直接内存 非虚拟机运行数据区 JDK的NIO类可以使用Native函数库直接分配堆外内存，也会出现OOM 2.虚拟机对象探秘 对象的创建 虚拟机遇到字节码new指令时的处理过程——第七章详解 对象的布局 对象头(Header) 实例数据(InstanceData) 3.OOM异常 分析OOM 确认是内存泄漏(Memory Leak) 还是内存溢出(Menory OverFlow) ，分析内存映像。 扩展虚拟机内存设置 检查代码问题 虚拟机栈和本地方法栈溢出 制造溢出场景的方法：减少栈内存容量并通制造大量本地变量，增大次方法帧中的变量表长度2.使用默认参数时，HotSpot虚拟机的栈深度一般可以达到1000~2000 方法区和运行时常量池溢出","link":"/2020/08/02/2020-08-02-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"title":"我的书单","text":"阅读计划《spring-framework-reference》《Redis设计与实现》《Java并发编程的艺术》《Linux内核设计的艺术》《深入理解Kafka》《Go语言——从入门到进阶实战》《操作系统》 2020年阅读记录二月《Spring实战》 三月《SpringBoot揭秘：快速构建微服务体系》《SpringBoot开发实战》 四月None 五月《Python编程：从入门到实践》 六月《网络是怎样连接的》 七月《操作系统》——30% 八月《深入理解JVM虚拟机》","link":"/2020/08/02/2020-08-02-%E6%88%91%E7%9A%84%E4%B9%A6%E5%8D%95/"},{"title":"字节码文件","text":"前言字节码文件是Java程序运行的载体，想要理解Java程序运行的原理，了解字节码文件的内容是重要的一步。最近小小地研究了一下字节码文件中究竟有什么奥秘。 查看字节码使用javap对class文件进行反编译，即可查看字节码文件的内容或者使用vscode中的HexDump插件，可以直接以十六进制的形式查看原始的二进制字节码文件 字节码文件格式字节文件中包含魔数、次版本号、主版本号、常量池、常量池 魔数与版本号魔数唯一的作用是识别文件是否是一个能被JVM接受的Class文件。次版本号和主版本号都是用于识别当前的JDK版本。高版本JDK能向下兼容旧版本的Class文件。 常量池与常量池容量常量池用于存储字面量（Literal）和符号引用（SymbolicReferences）。 字面量字面量接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。 符号引用符号引用包括下面三类常量 类与接口的全限定名（Fully Qualified Name） 字段的名称和描述符（Descriptor） 方法的名称和描述符 常量池中的每一项常量都是一中类似列表的数据结构，其首位存储标志位，用于标记是什么类型的常量，紧接着的数据由不同的常量结构来决定常量池中存储的信息有： 各类型基本及字符串数据字面量 字段、类、接口、字段或方法的部分符号引用 方法句柄 方法类型标识 动态方法调用点 这里有几个点可以关注一下： CONSTANT_String_info常量标识String的字面量，其结构大致可表示如下： 1234CONSTANT_String_info { u1 tag; u2 string_index; } 其并不直接存储字符串数据，只保存了常量池索引，索引会指向另一个CONSTANT_Utf8_info常量，这个才是存储字符串数据的常量。 CONSTANT_Utf8_info常量的结构大致可表示如下： 12345678910CONSTANT_Utf8_info { u1 tag; u2 length; u1 bytes; u1 bytes; u1 bytes; . . .(bytes数据有length个)} length值说明了这个UTF-8编码的字符串长度是多少字节，它后面紧跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串。由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名称，故CONSTANT_Utf8_info型常量的最大长度就是Java中方法、字段名的最大长度。又由于u2类型能表达的最大值为65535，所以Java程序中定义了超过64KB英文字符的变量或方法名，将会无法编译。同理，由字符串字面量的定义可知，在编译期，理论上字符串长度最大为65535，而由于javac程序的范围判断（具体可查看javac源码，是&gt;与&gt;=的区别），最大长度实际上是65534。 访问标志(access_flags)在常量池结束后的数据是访问标志，用于标识类或接口层层的访问信息，比如这个Class是接口还是类，是否定义为public，是否定义为abstract等。 类索引、父类索引与接口索引集合用来描述类的继承信息的数据，索引会指向常量池，找出对应的类名、接口名、父类名（均为全限定名） 字段表集合(field_info)用于描述接口或类中声明的变量的数据，其中包括变量的作用域、是实例变量还是类变量（static）、可变性（final）、并发可见性（violatile）、可否被序列化（transient）、字段数据类型、字段名称等。access_flags是描述符列表，name_index和descriptior_index都是对常量池的引用，分别代表字段的简单名称和描述符。描述符的作用是用来描述字段的数据类型、方法的参数列表和返回值。 方法表集合（method_info）方法表集合与字段表集合的声明方式几乎一致，只是方法不能用volatile修饰和transient修饰，所以方法表集合中的access_flags中不会出现这两个标志，与之对应的是多了synchronized、abstract标志。","link":"/2021/01/24/2021-01-24-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6/"},{"title":"【阅读笔记】深入理解JVM虚拟机：第三章","text":"对象已死？ 1.垃圾回收算法介绍 引用计数算法 很难解决对象间相互循环引用的问题，当外部没有引用时无法GC 可达性分析算法 通过GC Roots作为起始点集，根据与GC Roots是否有引用链相连来判断是否需要回收 可作为GC Roots的对象： 线程间共享的元数据（如方法区里的对象） 线程启动以来的方法调用栈（如虚拟机栈和本地方法栈里引用的对象） 2.再谈引用 强引用 普通的引用赋值 只要存在强引用关系就不会GC 软引用 有用但非必须 系统将要OOM前会进行回收 弱引用 比软引用更弱的引用 被弱引用关联的对象在下一次GC时就会被回收 虚引用 设置虚引用只是为了其在GC时收到一个系统通知，不会对其他生存时间构成影响，也不能通过虚引用获取实例对象 3.生存还是死亡？ 可达性算法分析为不可达后的处理过程 P186 概述：不可达对象不会被立即回收，可以最多一次使用系统调用的finalize()方法重新建立引用来自救 垃圾收集算法1.标记-清除算法 标记需要回收的内存，直接进行清除 缺点：标记和清除的执行效率会随对象数量增长而降低；会产生大量不连续的内存碎片 2.标记-复制算法 回收新生代内存的优先选择 缺点：因为会进行复制，在对象存活率较高时效率会降低，一般不在老年代对象中使用 3.标记-整理算法 标记-&gt;将存货对象移动到内存空间另一端-&gt;清除存活边界以外的内存","link":"/2020/08/03/2020-08-03-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"title":"springboot启动流程源码解析","text":"好好啃一下这块硬骨头 前言虽然目前springboot目前已经迭代待2.5.x版本了，但鉴于springboot2.4.x版本后新增了springcloud的相关内容且相较于以前的版本代码风格有了比较大的变动，本文使用的springboot版本为2.3.9、JDK8版本。springboot的奥秘集中在三点：SpringApplication对象的创建，静态方法SpringApplication.run的执行以及一些关键注解的作用，所以本文会围绕这三点来进行源码分析。 一.构造SpringApplication对象main方法调用SpringApplication.run静态方法，并传入main方法所在的启动引导类SpringbootLearningApplicationApplication.class新建SpringApplication对象，并将引导类传入其构造方法然后进入第一个关键步骤，SpringApplication对象的创建。我们先来看下SpringApplication的构造方法。构造方法有两个参数，resourceLoader和primarySources，resourceLoader一般会置空，然后会在后续步骤中加载DefaultResourceLoader。primarySources是引导类，用于作为整个项目资源路径的引导标识，目前暂时还没见过有传多个引导类的情况。然后开始进行spring应用的资源初始化。 首先是应用类别判断。WebApplicationType.deduceFromClasspath()方法通过ClassUtils.isPresent方法判断当前ClassLoader中是否存在相应的类来决定应该初始化哪种类型的应用，如果我们引入了springboot-starter-web模块，则web应用都类型是SERVLET，本文也是基于这个类型来进行分析。 其次是各种资源的加载。在这里我们要重点关注getSpringFactoriesInstances方法，后面的ApplicationContextInitializer和ApplicationListener都是通过该方法进行加载的。initializers和listeners都是在此处进行赋值，便于后续spring容器刷新时对相应的对象做处理（回调）。getSpringFactoriesInstances方法会调起SpringFactoriesLoader.loadFactoryNames()方法，最终调用loadSpringFactories()方法，这个方法是Spring提供的SPI机制的实现。SpringFactoriesLoader类会在第一次调用loadSpringFactories方法时扫描当前ClassLoader所处理的路径下所有META-INF/spring.factories文件的配置信息，来找到需要加载到Spring容器中的类，并缓存起来。这里的ClassLoader是ApplicationClassLoader，会加载用户类路径上的类库，具体可以参考这篇文章：《JVM类加载机制》。简单来说，就是通过查找用户路径类库中的META-INF/spring.factories文件，来找到需要加载到Spring容器中的类，如果我们需要在这些扩展点进行扩展，只需要将自定义的类按照Spring的SPI规范进行编写，便可以将类在启动阶段载入到SpringApplication对象中。springboot在启动流程的扩展机制，基本上都是使用这种方式进行的。这里我们要搞清楚一个概念，和我们平时理解的工厂模式不同，虽然这个方法名叫做getSpringFactoriesInstances，但最终拿到的东西并不是一系列工厂实例集合，不是很清楚为什么要这样子命名。 最后的deduceMainApplicationClass()是用来记录引导类的信息的，暂时没有什么很大作用。 至此，一个SpringApplication对象就构建完成了。 二、SpringApplication.runSpringApplication对象构建完后，接下来就该让它跑起来了。在run方法中，有一些步骤我们没有必要去了解，这里我们只去关心有意义的步骤（比如设置显示器配置这种步骤我们直接略过就好）。 首先是进行监听器的初始化。这里的监听器和上面提到的监听器不同，实现的是SpringApplicationRunListener接口。我们可以深入以下两行代码看下其中的逻辑。 12SpringApplicationRunListeners listeners = getRunListeners(args);listeners.starting(bootstrapContext, this.mainApplicationClass); getRunListeners方法还是Spring提供的一个SPI扩展点，在底层还是去读取META-INF/spring.factories来读取SpringApplicationRunListener，与其他的扩展机制并无二致，只不过在外部进行了一层封装，将所有的SpringApplicationRunListener封装为一个SpringApplicationRunListeners对象。这里一般也不会有太多扩展，可以看到这里只加载了一个EventPublishRunListener，用于进行Spring应用启动的时间发布。然后是下面这个starting方法。这里必须得吐槽一下，在2.4.x版本，springboot有很多代码在2.4.0版本后这个方法完全用lamda表达式重写了一遍，不得不说可读性是真的一般。这些改动主要是为了增加SpringCloud的相关支持，和一般的springboot应用启动流程起始并不是很相关。最开始我看的是2.4.2版本的代码，属实难顶，这也是为什么在前言中建议只想学习springboot启动流程的话可以去看2.3.x的代码。 starting方法很简单，就是将所有listener遍历并进行事件发布。由于一般SpringApplicationRunListener的实现类只有EventPublishingRunListener，所以我们可以进一步查看这个类的代码。EventPublishingRunListener会构造一个SimpleApplicationEventMulticaster事件广播器，并将SpringApplication对象在构造方法中加载的Listener缓存在广播器中，并在starting方法会广播一个ApplicationStartingEvent，剩下的就是将事件广播给在onApplication方法中监听了这个事件的监听器了。详细步骤可以去阅读SimpleApplicationEventMulticaster的代码。所以如果我们要对spring启动监听器进行扩展，只需要按上面提到的SpringSPI方式将监听器注册到SpringApplication对象中（注意，不是容器哦，Spring容器到目前为止还没有进行创建），就可以对这些扩展点时间进行监听并执行相应的操作了。 接下来是进行配置环境的加载，就是根据一定的优先级去进行各个配置源的信息读取。各个步骤底层会涉及非常多的读取解析逻辑，但是这些步骤Springboot除了扩展点外和Spring并没有太大区别，我们就不深入到底层代码中去探索了，可以简略的看下关键步骤做的事情。Spring应用的环境配置由ConfigurableEnvironment对象负责处理，配置的步骤在SpringApplication#prepareEnvironment方法中 12345678910111213141516171819private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments) { // Create and configure the environment // 创建ConfigurableEnvironment实例 ConfigurableEnvironment environment = getOrCreateEnvironment(); // 将启动参数绑定到ConfigurableEnvironment中 configureEnvironment(environment, applicationArguments.getSourceArgs()); ConfigurationPropertySources.attach(environment); // springboot通过广播ApplicationEnvironmentPreparedEvent事件设置了一个扩展点 // 如果我们需要在环境准备阶段进行扩展，比如以微服务方式通过配置中心读取配置等，可以在这一步添加监听器来进行扩展 listeners.environmentPrepared(bootstrapContext, environment); bindToSpringApplication(environment); // 自定义的EnvironmentConverter配置和解析，比较少用 if (!this.isCustomEnvironment) { environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment, deduceEnvironmentClass()); } ConfigurationPropertySources.attach(environment); return environment;} 下一步比较关键的步骤就是重量级的容器创建了，这里值得我们再细分几步来分析。Spring容器的相关知识可以参考我的另一篇文章《SpringIoc》 2.1 createApplicationContext首先，会通过反射的方式根据应用类型来创建容器类型实例，这里返回得容器类型是AnnotationConfigServletWebServerApplicationContext，然后会强制转换为ConfigurableApplicationContext下一步加载exceptionReporters是通过SPI扩展的方式加载SpringBootExceptionReporter，这里主要是用于对springboot应用启动时发生的错误进行处理的，我们一般也不会去做太多的扩展，exceptionReporters也不会进入到容器中，在此我们不做深入分析 12exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[] { ConfigurableApplicationContext.class }, context); 2.2 prepareContext紧接着是容器准备阶段。这个阶段主要是进行一些容器的预配置工作。 12345678910111213141516171819202122232425262728293031private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) { // 设置容器的环境对象 context.setEnvironment(environment); // postProcessApplicationContext(context); applyInitializers(context); listeners.contextPrepared(context); if (this.logStartupInfo) { logStartupInfo(context.getParent() == null); logStartupProfileInfo(context); } // Add boot specific singleton beans ConfigurableListableBeanFactory beanFactory = context.getBeanFactory(); beanFactory.registerSingleton(\"springApplicationArguments\", applicationArguments); if (printedBanner != null) { beanFactory.registerSingleton(\"springBootBanner\", printedBanner); } if (beanFactory instanceof DefaultListableBeanFactory) { ((DefaultListableBeanFactory) beanFactory) .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); } if (this.lazyInitialization) { context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor()); } // Load the sources Set&lt;Object&gt; sources = getAllSources(); Assert.notEmpty(sources, \"Sources must not be empty\"); load(context, sources.toArray(new Object[0])); listeners.contextLoaded(context); }","link":"/2021/02/23/2021-02-10-springboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"other","slug":"other","link":"/tags/other/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"reading","slug":"reading","link":"/tags/reading/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"}],"categories":[{"name":"other","slug":"other","link":"/categories/other/"},{"name":"reading note","slug":"reading-note","link":"/categories/reading-note/"},{"name":"article","slug":"article","link":"/categories/article/"}]}